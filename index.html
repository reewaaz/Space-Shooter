<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Vector: Space Survivor</title>
    <style>
        :root {
            --primary: #0ff;
            --danger: #f05;
            --ui-bg: rgba(0, 20, 40, 0.5);
            --border: rgba(255, 255, 255, 0.3);
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Courier New', Courier, monospace;
            touch-action: none; /* Prevents scrolling on mobile */
            user-select: none;
            -webkit-user-select: none;
        }

        canvas {
            display: block;
        }

        /* UI OVERLAYS */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Let touches pass through to canvas controls */
        }

        /* WEAPON SELECTOR (Top Right) */
        #weapon-hud {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            pointer-events: auto;
        }

        .weapon-slot {
            width: 50px;
            height: 50px;
            border: 2px solid var(--border);
            background: var(--ui-bg);
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: bold;
            font-size: 20px;
            transition: 0.2s;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
        }

        .weapon-slot.active {
            border-color: var(--primary);
            box-shadow: 0 0 15px var(--primary);
            transform: scale(1.1);
        }

        /* MOBILE CONTROLS VISUALS */
        .joystick-zone {
            position: absolute;
            bottom: 50px;
            width: 150px;
            height: 150px;
            border-radius: 50%;
            border: 2px dashed rgba(255, 255, 255, 0.1);
            display: none; /* Hidden on desktop by default */
            pointer-events: none; /* Logic handled by JS touch events globally */
            justify-content: center;
            align-items: center;
        }
        
        .joystick-knob {
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.5);
            transform: translate(0, 0);
        }

        #stick-left { left: 40px; }
        #stick-right { right: 40px; }

        /* SWITCH BUTTON (Mobile Only - Bottom Right) */
        #mobile-switch-btn {
            position: absolute;
            bottom: 40px;
            right: 180px; /* To the left of the aim stick */
            width: 60px;
            height: 60px;
            border: 2px solid var(--primary);
            border-radius: 50%;
            background: rgba(0, 255, 255, 0.1);
            color: var(--primary);
            display: none; /* Visible via JS on touch devices */
            justify-content: center;
            align-items: center;
            font-size: 12px;
            text-transform: uppercase;
            pointer-events: auto;
            backdrop-filter: blur(4px);
        }
        
        #mobile-switch-btn:active {
            background: var(--primary);
            color: black;
        }

        /* START SCREEN */
        #start-screen, #game-over-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 100;
            pointer-events: auto;
        }

        h1 {
            font-size: 4rem;
            text-shadow: 0 0 20px var(--primary);
            margin-bottom: 10px;
            text-align: center;
        }
        
        p { font-size: 1.2rem; color: #aaa; text-align: center; max-width: 600px;}

        button.main-btn {
            padding: 15px 40px;
            font-size: 1.5rem;
            background: transparent;
            color: var(--primary);
            border: 2px solid var(--primary);
            margin-top: 30px;
            cursor: pointer;
            font-family: inherit;
            box-shadow: 0 0 10px var(--primary);
            transition: 0.3s;
        }

        button.main-btn:hover {
            background: var(--primary);
            color: #000;
            box-shadow: 0 0 30px var(--primary);
        }

        #score-display {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 24px;
            font-weight: bold;
        }

        @media (max-width: 768px) {
            h1 { font-size: 2.5rem; }
            .joystick-zone, #mobile-switch-btn { display: flex; }
        }
    </style>
</head>
<body>

    <!-- UI Overlay -->
    <div id="ui-layer">
        <div id="score-display">SCORE: 0</div>

        <!-- Weapon HUD (Top Right per sketch) -->
        <div id="weapon-hud">
            <div class="weapon-slot active" id="slot-0" onclick="game.switchWeapon(0)">I</div>
            <div class="weapon-slot" id="slot-1" onclick="game.switchWeapon(1)">II</div>
            <div class="weapon-slot" id="slot-2" onclick="game.switchWeapon(2)">III</div>
        </div>

        <!-- Mobile Controls visuals -->
        <div id="stick-left" class="joystick-zone">
            <div class="joystick-knob" id="knob-left"></div>
        </div>
        <div id="stick-right" class="joystick-zone">
            <div class="joystick-knob" id="knob-right"></div>
        </div>
        
        <!-- Quick Switch Button (Mobile) -->
        <div id="mobile-switch-btn" onclick="game.cycleWeapon()">SWITCH</div>
    </div>

    <!-- Screens -->
    <div id="start-screen">
        <h1>NEON VECTOR</h1>
        <p>Left Stick / WASD to Move<br>Right Stick / Mouse to Aim & Shoot</p>
        <button class="main-btn" onclick="startGame()">INITIATE</button>
    </div>

    <div id="game-over-screen" style="display: none;">
        <h1 style="color: var(--danger); text-shadow: 0 0 20px var(--danger);">CRITICAL FAILURE</h1>
        <p>Final Score: <span id="final-score">0</span></p>
        <button class="main-btn" onclick="resetGame()">REBOOT SYSTEM</button>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        // --- AUDIO ENGINE (Synthesizer) ---
        const AudioEngine = {
            ctx: null,
            init: function() {
                window.AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();
            },
            playTone: function(freq, type, duration, vol = 0.1) {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            },
            shoot: function(type) {
                if(type === 0) this.playTone(400, 'square', 0.1, 0.05); // Blaster
                if(type === 1) this.playTone(150, 'sawtooth', 0.2, 0.05); // Shotgun
                if(type === 2) this.playTone(800, 'sine', 0.1, 0.05); // Sniper
            },
            explode: function() {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(1, this.ctx.currentTime + 0.5);
                gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.5);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.5);
            },
            switch: function() {
                this.playTone(600, 'sine', 0.1, 0.05);
            },
            bgmOsc: null,
            startMusic: function() {
                if(!this.ctx) return;
                // Simple looping bassline
                let notes = [110, 110, 220, 110, 164, 110, 130, 98]; 
                let noteIndex = 0;
                setInterval(() => {
                    if(game.state !== 'playing') return;
                    this.playTone(notes[noteIndex], 'triangle', 0.2, 0.05);
                    noteIndex = (noteIndex + 1) % notes.length;
                }, 250);
            }
        };

        // --- GAME SETUP ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Resize handling
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        // Game State
        const game = {
            state: 'menu', // menu, playing, gameover
            score: 0,
            width: 0,
            height: 0,
            shake: 0,
            lastTime: 0,
            enemySpawnTimer: 0,
            enemySpawnRate: 1000,
            
            player: {
                x: 0, y: 0, 
                vx: 0, vy: 0, 
                angle: 0,
                radius: 15,
                speed: 5,
                weaponIndex: 0,
                cooldown: 0,
                hp: 100
            },
            
            weapons: [
                { name: 'Blaster', rate: 150, speed: 12, damage: 10, count: 1, spread: 0, color: '#0ff' }, // Rapid
                { name: 'Spread', rate: 500, speed: 10, damage: 8, count: 5, spread: 0.5, color: '#ff0' }, // Shotgun
                { name: 'Rail', rate: 800, speed: 20, damage: 50, count: 1, spread: 0, color: '#f0f' }  // Sniper
            ],

            bullets: [],
            enemies: [],
            particles: [],
            stars: [],

            // Input State
            keys: {},
            mouse: { x: 0, y: 0, down: false },
            joystickLeft: { x: 0, y: 0, active: false, id: null, originX: 0, originY: 0 },
            joystickRight: { x: 0, y: 0, active: false, id: null, originX: 0, originY: 0 },

            switchWeapon: function(index) {
                if(this.state !== 'playing') return;
                this.player.weaponIndex = index;
                AudioEngine.switch();
                updateWeaponUI();
            },
            cycleWeapon: function() {
                let next = (this.player.weaponIndex + 1) % 3;
                this.switchWeapon(next);
            }
        };

        function updateWeaponUI() {
            for(let i=0; i<3; i++) {
                const el = document.getElementById(`slot-${i}`);
                if(i === game.player.weaponIndex) el.classList.add('active');
                else el.classList.remove('active');
            }
        }

        // --- INPUT HANDLING ---

        // Keyboard & Mouse
        window.addEventListener('keydown', e => {
            game.keys[e.code] = true;
            if(e.code === 'Digit1') game.switchWeapon(0);
            if(e.code === 'Digit2') game.switchWeapon(1);
            if(e.code === 'Digit3') game.switchWeapon(2);
            if(e.code === 'Space') game.cycleWeapon();
        });
        window.addEventListener('keyup', e => game.keys[e.code] = false);
        window.addEventListener('mousemove', e => {
            game.mouse.x = e.clientX;
            game.mouse.y = e.clientY;
        });
        window.addEventListener('mousedown', () => game.mouse.down = true);
        window.addEventListener('mouseup', () => game.mouse.down = false);

        // Touch (Virtual Joysticks)
        const leftZone = document.getElementById('stick-left');
        const rightZone = document.getElementById('stick-right');
        const leftKnob = document.getElementById('knob-left');
        const rightKnob = document.getElementById('knob-right');

        // Helper to get rect for touch zones
        const leftRect = leftZone.getBoundingClientRect();
        const rightRect = rightZone.getBoundingClientRect();
        const stickRadius = 75; // Half of 150px

        // Determine stick centers dynamically based on CSS layout
        function getStickCenters() {
            return {
                lx: leftRect.left + stickRadius,
                ly: leftRect.top + stickRadius,
                rx: rightRect.left + stickRadius,
                ry: rightRect.top + stickRadius
            };
        }

        window.addEventListener('touchstart', e => {
            const centers = getStickCenters();
            for (let i = 0; i < e.changedTouches.length; i++) {
                const t = e.changedTouches[i];
                // Check Left side
                if (t.clientX < window.innerWidth / 2) {
                    if(!game.joystickLeft.active) {
                        game.joystickLeft.id = t.identifier;
                        game.joystickLeft.active = true;
                        updateStick(t, game.joystickLeft, centers.lx, centers.ly, leftKnob);
                    }
                } 
                // Check Right side (excluding UI buttons roughly)
                else if (t.clientY > 100) { // Avoid top weapon bar
                    if(!game.joystickRight.active) {
                        game.joystickRight.id = t.identifier;
                        game.joystickRight.active = true;
                        updateStick(t, game.joystickRight, centers.rx, centers.ry, rightKnob);
                    }
                }
            }
        }, {passive: false});

        window.addEventListener('touchmove', e => {
            e.preventDefault(); // Stop scrolling
            const centers = getStickCenters();
            for (let i = 0; i < e.changedTouches.length; i++) {
                const t = e.changedTouches[i];
                if (t.identifier === game.joystickLeft.id) {
                    updateStick(t, game.joystickLeft, centers.lx, centers.ly, leftKnob);
                }
                if (t.identifier === game.joystickRight.id) {
                    updateStick(t, game.joystickRight, centers.rx, centers.ry, rightKnob);
                }
            }
        }, {passive: false});

        const resetStick = (stick, knob) => {
            stick.active = false;
            stick.id = null;
            stick.x = 0;
            stick.y = 0;
            knob.style.transform = `translate(0px, 0px)`;
        };

        window.addEventListener('touchend', e => {
            for (let i = 0; i < e.changedTouches.length; i++) {
                const t = e.changedTouches[i];
                if (t.identifier === game.joystickLeft.id) resetStick(game.joystickLeft, leftKnob);
                if (t.identifier === game.joystickRight.id) resetStick(game.joystickRight, rightKnob);
            }
        });

        function updateStick(touch, stickObj, centerX, centerY, knobElement) {
            const maxDist = 40; // Max visual movement of knob
            let dx = touch.clientX - centerX;
            let dy = touch.clientY - centerY;
            
            // Normalize input -1 to 1
            const dist = Math.sqrt(dx*dx + dy*dy);
            
            if (dist > stickRadius) {
                const ratio = stickRadius / dist;
                dx *= ratio;
                dy *= ratio;
            }

            // Visual update
            const visualDist = Math.min(dist, maxDist);
            const angle = Math.atan2(dy, dx);
            const vx = Math.cos(angle) * visualDist;
            const vy = Math.sin(angle) * visualDist;
            knobElement.style.transform = `translate(${vx}px, ${vy}px)`;

            // Logic update (normalized -1 to 1)
            stickObj.x = dx / stickRadius;
            stickObj.y = dy / stickRadius;
        }


        // --- GAME LOGIC ---

        function initGame() {
            game.player.x = canvas.width / 2;
            game.player.y = canvas.height / 2;
            game.bullets = [];
            game.enemies = [];
            game.particles = [];
            game.score = 0;
            game.enemySpawnRate = 1000;
            game.shake = 0;
            
            // Generate Stars
            game.stars = [];
            for(let i=0; i<100; i++) {
                game.stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 2,
                    speed: Math.random() * 0.5 + 0.1
                });
            }
        }

        function spawnEnemy() {
            const edge = Math.floor(Math.random() * 4); // 0:top, 1:right, 2:bottom, 3:left
            let ex, ey;
            const size = 20;
            
            if(edge === 0) { ex = Math.random() * canvas.width; ey = -size; }
            else if(edge === 1) { ex = canvas.width + size; ey = Math.random() * canvas.height; }
            else if(edge === 2) { ex = Math.random() * canvas.width; ey = canvas.height + size; }
            else { ex = -size; ey = Math.random() * canvas.height; }

            // Types: 0 = Follower (Fast, Low HP), 1 = Tank (Slow, High HP)
            const type = Math.random() > 0.8 ? 1 : 0;
            
            game.enemies.push({
                x: ex, y: ey,
                type: type,
                hp: type === 0 ? 20 : 60,
                speed: type === 0 ? 2 + Math.random() : 1,
                size: type === 0 ? 20 : 30,
                color: type === 0 ? '#f55' : '#f90',
                angle: 0
            });
        }

        function createParticles(x, y, color, count) {
            for(let i=0; i<count; i++) {
                game.particles.push({
                    x: x, y: y,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    life: 1.0,
                    color: color
                });
            }
        }

        function update(dt) {
            if(game.state !== 'playing') return;

            // --- Player Movement ---
            let dx = 0, dy = 0;

            // Keyboard
            if(game.keys['KeyW'] || game.keys['ArrowUp']) dy = -1;
            if(game.keys['KeyS'] || game.keys['ArrowDown']) dy = 1;
            if(game.keys['KeyA'] || game.keys['ArrowLeft']) dx = -1;
            if(game.keys['KeyD'] || game.keys['ArrowRight']) dx = 1;

            // Touch (Joystick) overrides keyboard if active
            if(game.joystickLeft.active) {
                dx = game.joystickLeft.x;
                dy = game.joystickLeft.y;
            }

            // Apply movement
            game.player.x += dx * game.player.speed;
            game.player.y += dy * game.player.speed;

            // Bounds
            game.player.x = Math.max(game.player.radius, Math.min(canvas.width - game.player.radius, game.player.x));
            game.player.y = Math.max(game.player.radius, Math.min(canvas.height - game.player.radius, game.player.y));

            // --- Aiming & Shooting ---
            let aimAngle = 0;
            let isFiring = false;

            if(game.joystickRight.active) {
                // Mobile Aim
                const dist = Math.sqrt(game.joystickRight.x**2 + game.joystickRight.y**2);
                if(dist > 0.2) { // Deadzone
                    aimAngle = Math.atan2(game.joystickRight.y, game.joystickRight.x);
                    game.player.angle = aimAngle;
                    isFiring = true; // Auto fire on mobile when aiming
                }
            } else {
                // Mouse Aim
                dx = game.mouse.x - game.player.x;
                dy = game.mouse.y - game.player.y;
                aimAngle = Math.atan2(dy, dx);
                game.player.angle = aimAngle;
                isFiring = game.mouse.down;
            }

            // Weapon Cooldown & Fire
            if(game.player.cooldown > 0) game.player.cooldown -= dt;
            
            if(isFiring && game.player.cooldown <= 0) {
                const w = game.weapons[game.player.weaponIndex];
                game.player.cooldown = w.rate;
                AudioEngine.shoot(game.player.weaponIndex);
                if(navigator.vibrate) navigator.vibrate(20); // Haptic

                // Spawn bullets
                const startAngle = w.count > 1 ? -w.spread / 2 : 0;
                const step = w.count > 1 ? w.spread / (w.count - 1) : 0;

                for(let i=0; i<w.count; i++) {
                    const angleOffset = startAngle + (step * i);
                    const finalAngle = game.player.angle + angleOffset;
                    game.bullets.push({
                        x: game.player.x + Math.cos(finalAngle) * 20,
                        y: game.player.y + Math.sin(finalAngle) * 20,
                        vx: Math.cos(finalAngle) * w.speed,
                        vy: Math.sin(finalAngle) * w.speed,
                        damage: w.damage,
                        color: w.color
                    });
                }
            }

            // --- Update Bullets ---
            for(let i = game.bullets.length - 1; i >= 0; i--) {
                const b = game.bullets[i];
                b.x += b.vx;
                b.y += b.vy;
                // Screen cleanup
                if(b.x < 0 || b.x > canvas.width || b.y < 0 || b.y > canvas.height) {
                    game.bullets.splice(i, 1);
                }
            }

            // --- Update Enemies ---
            // Spawn logic
            game.enemySpawnTimer -= dt;
            if(game.enemySpawnTimer <= 0) {
                spawnEnemy();
                game.enemySpawnTimer = game.enemySpawnRate;
                // Ramp up difficulty
                if(game.enemySpawnRate > 200) game.enemySpawnRate -= 5;
            }

            for(let i = game.enemies.length - 1; i >= 0; i--) {
                const e = game.enemies[i];
                // Move towards player
                const angle = Math.atan2(game.player.y - e.y, game.player.x - e.x);
                e.x += Math.cos(angle) * e.speed;
                e.y += Math.sin(angle) * e.speed;
                e.angle += 0.05;

                // Collision with Bullets
                let hit = false;
                for(let j = game.bullets.length - 1; j >= 0; j--) {
                    const b = game.bullets[j];
                    const dist = Math.hypot(e.x - b.x, e.y - b.y);
                    if(dist < e.size + 5) {
                        e.hp -= b.damage;
                        game.bullets.splice(j, 1);
                        createParticles(b.x, b.y, b.color, 3);
                        hit = true;
                        break;
                    }
                }

                // Check death
                if(e.hp <= 0) {
                    AudioEngine.explode();
                    createParticles(e.x, e.y, e.color, 15);
                    game.score += (e.type === 0 ? 100 : 300);
                    game.enemies.splice(i, 1);
                    game.shake = 5;
                    continue;
                }

                // Collision with Player
                const pDist = Math.hypot(e.x - game.player.x, e.y - game.player.y);
                if(pDist < e.size + game.player.radius) {
                    gameOver();
                }
            }

            // --- Update Particles ---
            for(let i = game.particles.length - 1; i >= 0; i--) {
                const p = game.particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.05;
                if(p.life <= 0) game.particles.splice(i, 1);
            }

            // --- Screen Shake Decay ---
            if(game.shake > 0) game.shake *= 0.9;
            if(game.shake < 0.5) game.shake = 0;

            // Score UI
            document.getElementById('score-display').innerText = `SCORE: ${game.score}`;
        }

        function draw() {
            // Background & Shake
            ctx.save();
            const shakeX = (Math.random() - 0.5) * game.shake;
            const shakeY = (Math.random() - 0.5) * game.shake;
            ctx.translate(shakeX, shakeY);

            ctx.fillStyle = '#050505';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Grid (Retro effect)
            ctx.strokeStyle = '#001122';
            ctx.lineWidth = 1;
            ctx.beginPath();
            for(let x=0; x<canvas.width; x+=50) { ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); }
            for(let y=0; y<canvas.height; y+=50) { ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); }
            ctx.stroke();

            // Stars
            ctx.fillStyle = '#fff';
            game.stars.forEach(s => {
                ctx.beginPath();
                ctx.arc(s.x, s.y, s.size, 0, Math.PI*2);
                ctx.fill();
                s.y += s.speed;
                if(s.y > canvas.height) s.y = 0;
            });

            if(game.state === 'playing') {
                // Player
                ctx.save();
                ctx.translate(game.player.x, game.player.y);
                ctx.rotate(game.player.angle);
                
                // Ship shape (Triangle)
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#0ff';
                ctx.strokeStyle = '#0ff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(20, 0); // Nose
                ctx.lineTo(-15, 15);
                ctx.lineTo(-5, 0); // Engine indent
                ctx.lineTo(-15, -15);
                ctx.closePath();
                ctx.stroke();
                
                // Weapon Indicator
                const wColor = game.weapons[game.player.weaponIndex].color;
                ctx.fillStyle = wColor;
                ctx.beginPath();
                ctx.arc(0, 0, 5, 0, Math.PI*2);
                ctx.fill();

                ctx.restore();

                // Bullets
                game.bullets.forEach(b => {
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = b.color;
                    ctx.fillStyle = b.color;
                    ctx.beginPath();
                    ctx.arc(b.x, b.y, 3, 0, Math.PI*2);
                    ctx.fill();
                });

                // Enemies
                game.enemies.forEach(e => {
                    ctx.save();
                    ctx.translate(e.x, e.y);
                    ctx.rotate(e.angle);
                    
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = e.color;
                    ctx.strokeStyle = e.color;
                    ctx.lineWidth = 2;
                    
                    // Square shape with X inside (per sketch)
                    const s = e.size;
                    ctx.strokeRect(-s/2, -s/2, s, s);
                    ctx.beginPath();
                    ctx.moveTo(-s/2, -s/2); ctx.lineTo(s/2, s/2);
                    ctx.moveTo(s/2, -s/2); ctx.lineTo(-s/2, s/2);
                    ctx.stroke();

                    ctx.restore();
                });

                // Particles
                game.particles.forEach(p => {
                    ctx.globalAlpha = p.life;
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 2 + Math.random()*2, 0, Math.PI*2);
                    ctx.fill();
                    ctx.globalAlpha = 1.0;
                });
            }

            ctx.restore();
        }

        function loop(timestamp) {
            const dt = timestamp - game.lastTime;
            game.lastTime = timestamp;

            update(dt);
            draw();

            requestAnimationFrame(loop);
        }

        // --- GAME CONTROLS ---

        function startGame() {
            AudioEngine.init();
            AudioEngine.startMusic();
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('ui-layer').style.display = 'block';
            game.state = 'playing';
            initGame();
        }

        function gameOver() {
            game.state = 'gameover';
            if(navigator.vibrate) navigator.vibrate(200);
            document.getElementById('game-over-screen').style.display = 'flex';
            document.getElementById('final-score').innerText = game.score;
        }

        function resetGame() {
            document.getElementById('game-over-screen').style.display = 'none';
            game.state = 'playing';
            initGame();
        }

        // Start Loop
        requestAnimationFrame(loop);

    </script>
</body>
</html>
