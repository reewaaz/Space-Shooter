<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NEON SQUADRON: Multiplayer Lobby</title>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Teko:wght@300;600&display=swap');

        :root {
            --p1-color: #00f3ff; /* Cyan */
            --p2-color: #ff00ff; /* Magenta */
            --p3-color: #ffff00; /* Yellow */
            --p4-color: #00ff00; /* Green */
            --bg-color: #0a0a12;
            --glass: rgba(255, 255, 255, 0.05);
        }

        * {
            box-sizing: border-box;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        body {
            margin: 0;
            background-color: var(--bg-color);
            overflow: hidden;
            font-family: 'Teko', sans-serif;
            color: white;
        }

        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
            filter: contrast(1.2) brightness(1.1);
        }

        /* --- UI & HUD --- */
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
        }

        .hud-header {
            display: flex; justify-content: space-between; padding: 10px 20px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.9), transparent);
            text-shadow: 0 0 10px rgba(255,255,255,0.3);
        }

        .score-board { font-size: 2rem; color: #fff; letter-spacing: 2px; }
        .wave-tracker { font-size: 1.5rem; color: var(--p2-color); }
        
        .player-status-row {
            display: flex; gap: 10px; margin-top: 5px;
        }
        .p-badge {
            width: 30px; height: 10px; border-radius: 2px; opacity: 0.3;
        }
        .p-badge.active { opacity: 1; box-shadow: 0 0 10px currentColor; }

        .hp-bar-wrapper {
            position: fixed; top: 10px; left: 50%; transform: translateX(-50%);
            width: 200px; height: 15px; background: #333; border: 1px solid #555; skew-x: -20deg;
        }
        .hp-bar { width: 100%; height: 100%; background: var(--p1-color); transition: width 0.2s; }

        /* --- CONTROLS --- */
        #controls-layer {
            position: absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; z-index:10;
        }
        .joy-zone {
            position: absolute; bottom: 30px; width: 140px; height: 140px; pointer-events: auto;
            border-radius: 50%; border: 2px dashed rgba(255,255,255,0.1);
            display: flex; justify-content: center; align-items: center;
        }
        #stick-l { left: 30px; }
        #stick-r { right: 30px; }
        
        .joy-thumb {
            width: 60px; height: 60px; background: rgba(255,255,255,0.2); border-radius: 50%;
            position: absolute; box-shadow: 0 0 20px rgba(0,243,255,0.3);
        }

        .weapon-btn {
            position: absolute; bottom: 180px; right: 20px; width: 60px; height: 60px;
            background: rgba(0,0,0,0.8); border: 1px solid #fff; border-radius: 50%;
            color: #fff; font-size: 30px; display: flex; align-items: center; justify-content: center;
            pointer-events: auto; z-index: 20;
        }

        /* --- SCREENS --- */
        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(10, 10, 16, 0.98);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 100;
        }
        .hidden { display: none !important; }

        h1 {
            font-size: 4rem; margin: 0; line-height: 1;
            background: linear-gradient(to right, var(--p1-color), var(--p2-color));
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            text-transform: uppercase; letter-spacing: 5px;
        }

        .btn {
            margin: 10px; padding: 15px 40px; font-size: 1.5rem;
            background: transparent; border: 2px solid var(--p1-color); color: var(--p1-color);
            font-family: 'Teko', sans-serif; text-transform: uppercase; cursor: pointer;
            transition: 0.3s;
        }
        .btn:active { background: var(--p1-color); color: #000; }
        .btn.disabled { opacity: 0.3; pointer-events: none; border-color: #555; color: #555; }

        /* LOBBY SPECIFIC */
        #lobby-list {
            width: 80%; max-width: 500px;
            background: rgba(255,255,255,0.05); padding: 20px;
            margin: 20px 0; border-radius: 10px; border: 1px solid #333;
        }
        .lobby-slot {
            display: flex; justify-content: space-between; align-items: center;
            padding: 10px; margin-bottom: 5px; background: rgba(0,0,0,0.3);
            border-left: 5px solid #333;
        }
        .lobby-slot.joined { border-left-color: var(--p1-color); background: rgba(0, 243, 255, 0.1); }
        
        #qr-container { background: #fff; padding: 10px; border-radius: 10px; margin: 10px; }
        
        #portrait-warning {
            display: none; position: fixed; top:0; left:0; width:100%; height:100%;
            background: #000; z-index: 999; flex-direction: column; 
            align-items: center; justify-content: center; color: var(--p1-color);
        }
        @media (orientation: portrait) { #portrait-warning { display: flex; } }

    </style>
</head>
<body>

    <div id="portrait-warning"><h1>ROTATE PHONE</h1></div>

    <canvas id="gameCanvas"></canvas>

    <!-- IN GAME HUD -->
    <div id="ui-layer" class="hidden">
        <div class="hud-header">
            <div>
                <div class="score-board" id="score-display">00000</div>
                <div class="player-status-row">
                    <!-- Dots for players -->
                    <div id="badge-p1" class="p-badge" style="color: var(--p1-color)"></div>
                    <div id="badge-p2" class="p-badge" style="color: var(--p2-color)"></div>
                    <div id="badge-p3" class="p-badge" style="color: var(--p3-color)"></div>
                    <div id="badge-p4" class="p-badge" style="color: var(--p4-color)"></div>
                </div>
            </div>
            <div class="wave-tracker" id="wave-display">WAVE 1</div>
        </div>
        <div class="hp-bar-wrapper">
            <div id="hp-fill" class="hp-bar"></div>
        </div>
        <div class="weapon-btn" id="btn-switch" onclick="switchWeapon()">ðŸ”«</div>
    </div>

    <!-- CONTROLS -->
    <div id="controls-layer" class="hidden">
        <div id="stick-l" class="joy-zone"><div class="joy-thumb" id="thumb-l"></div></div>
        <div id="stick-r" class="joy-zone"><div class="joy-thumb" id="thumb-r"></div></div>
    </div>

    <!-- MAIN MENU -->
    <div id="menu-screen" class="screen">
        <h1>NEON SQUADRON</h1>
        <p style="color:#888; letter-spacing: 2px;">MULTIPLAYER CO-OP DEFENSE</p>
        <button class="btn" onclick="startSingle()">SOLO MISSION</button>
        <button class="btn" onclick="setupHost()">CREATE LOBBY (HOST)</button>
        <div id="join-status" style="margin-top:20px; font-size: 1.2rem; color: var(--p1-color);"></div>
    </div>

    <!-- LOBBY SCREEN -->
    <div id="lobby-screen" class="screen hidden">
        <h2 style="margin:0; font-size: 3rem; color: #fff;">MISSION LOBBY</h2>
        <div id="qr-container"><img id="qr-img" width="150" height="150"></div>
        <p style="font-size: 1rem; color: #aaa;">Scan to Join</p>
        
        <div id="lobby-list">
            <div id="slot-p1" class="lobby-slot joined"><span>COMMANDER (YOU)</span><span style="color:var(--p1-color)">READY</span></div>
            <div id="slot-p2" class="lobby-slot"><span>PILOT 2</span><span>WAITING...</span></div>
            <div id="slot-p3" class="lobby-slot"><span>PILOT 3</span><span>WAITING...</span></div>
            <div id="slot-p4" class="lobby-slot"><span>PILOT 4</span><span>WAITING...</span></div>
        </div>

        <button id="start-btn" class="btn" onclick="hostStartGame()">LAUNCH MISSION</button>
        <p style="font-size: 0.8rem; color: #555;">Waiting for pilots...</p>
    </div>

    <!-- CLIENT WAITING SCREEN -->
    <div id="client-wait-screen" class="screen hidden">
        <h1>CONNECTED</h1>
        <p style="color: var(--p1-color); font-size: 1.5rem;">WAITING FOR COMMANDER TO LAUNCH...</p>
        <div class="p-badge active" id="my-color-badge" style="width: 50px; height: 50px; margin-top: 20px;"></div>
    </div>

<script>
/**
 * GAME & NETWORK ENGINE
 */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let W, H;

// Constants
const COLORS = ['#00f3ff', '#ff00ff', '#ffff00', '#00ff00']; // Cyan, Magenta, Yellow, Green

// Game State
const game = {
    active: false,
    mode: 'solo', // solo, host, client
    myId: 0, // 0=Host/P1, 1=P2, etc.
    players: {}, // Map of active players { 0: {x,y...}, 1: {x,y...} }
    bullets: [],
    enemies: [],
    particles: [],
    score: 0,
    wave: 1,
    shake: 0
};

// Local Input
const input = { x: 0, y: 0, aimX: 0, aimY: 0, firing: false, weapon: 0 };
let connList = []; // Host keeps track of connections

// --- AUDIO ---
const actx = new (window.AudioContext || window.webkitAudioContext)();
const playSound = (type) => {
    if(actx.state==='suspended') actx.resume();
    const osc = actx.createOscillator();
    const gain = actx.createGain();
    const now = actx.currentTime;
    
    if(type==='shoot') {
        osc.frequency.setValueAtTime(300, now);
        osc.frequency.exponentialRampToValueAtTime(100, now+0.1);
        gain.gain.setValueAtTime(0.05, now);
        gain.gain.linearRampToValueAtTime(0, now+0.1);
        osc.start(now); osc.stop(now+0.1);
    } else if(type==='exp') {
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(100, now);
        osc.frequency.exponentialRampToValueAtTime(10, now+0.3);
        gain.gain.setValueAtTime(0.1, now);
        gain.gain.linearRampToValueAtTime(0, now+0.3);
        osc.start(now); osc.stop(now+0.3);
    }
};

// --- RESIZE ---
const resize = () => { W=canvas.width=window.innerWidth; H=canvas.height=window.innerHeight; };
window.addEventListener('resize', resize);
resize();

// --- CONTROLS (Virtual Joystick) ---
const sticks = {
    l: { x:0, y:0, active:false, el:document.getElementById('thumb-l'), zone:document.getElementById('stick-l') },
    r: { x:0, y:0, active:false, el:document.getElementById('thumb-r'), zone:document.getElementById('stick-r') }
};

const handleTouch = (e, type) => {
    e.preventDefault();
    const touches = e.changedTouches;
    for(let i=0; i<touches.length; i++) {
        const t = touches[i];
        
        // Left Stick (Move)
        const rectL = sticks.l.zone.getBoundingClientRect();
        const distL = Math.hypot(t.clientX - (rectL.left+70), t.clientY - (rectL.top+70));
        
        if(type==='start' && distL < 70) sticks.l.id = t.identifier;
        if(t.identifier === sticks.l.id) {
            if(type==='end') {
                sticks.l.active = false; sticks.l.x=0; sticks.l.y=0;
                sticks.l.el.style.transform = `translate(0px,0px)`;
            } else {
                sticks.l.active = true;
                const dx = t.clientX - (rectL.left+70);
                const dy = t.clientY - (rectL.top+70);
                const ang = Math.atan2(dy, dx);
                const dist = Math.min(Math.hypot(dx,dy), 40);
                sticks.l.x = (Math.cos(ang)*dist)/40;
                sticks.l.y = (Math.sin(ang)*dist)/40;
                sticks.l.el.style.transform = `translate(${Math.cos(ang)*dist}px, ${Math.sin(ang)*dist}px)`;
            }
        }

        // Right Stick (Aim)
        const rectR = sticks.r.zone.getBoundingClientRect();
        const distR = Math.hypot(t.clientX - (rectR.left+70), t.clientY - (rectR.top+70));

        if(type==='start' && distR < 70) sticks.r.id = t.identifier;
        if(t.identifier === sticks.r.id) {
            if(type==='end') {
                sticks.r.active = false; input.firing = false;
                sticks.r.el.style.transform = `translate(0px,0px)`;
            } else {
                sticks.r.active = true; input.firing = true;
                const dx = t.clientX - (rectR.left+70);
                const dy = t.clientY - (rectR.top+70);
                const ang = Math.atan2(dy, dx);
                const dist = Math.min(Math.hypot(dx,dy), 40);
                input.aimX = Math.cos(ang);
                input.aimY = Math.sin(ang);
                sticks.r.el.style.transform = `translate(${Math.cos(ang)*dist}px, ${Math.sin(ang)*dist}px)`;
            }
        }
    }
};

const cLayer = document.getElementById('controls-layer');
cLayer.addEventListener('touchstart', e=>handleTouch(e,'start'), {passive:false});
cLayer.addEventListener('touchmove', e=>handleTouch(e,'move'), {passive:false});
cLayer.addEventListener('touchend', e=>handleTouch(e,'end'), {passive:false});

function switchWeapon() { input.weapon = (input.weapon+1)%3; }
const weapons = [
    { name:'PULSE', rate:10, dmg:20, spd:15, count:1, spread:0 },
    { name:'SHOTGUN', rate:30, dmg:15, spd:12, count:3, spread:0.3 },
    { name:'MINIGUN', rate:4, dmg:8, spd:18, count:1, spread:0.1 }
];

// --- CLASSES ---
class Particle {
    constructor(x,y,c) { this.x=x; this.y=y; this.c=c; this.life=1.0; this.v={x:(Math.random()-0.5)*5, y:(Math.random()-0.5)*5}; }
    update() { this.x+=this.v.x; this.y+=this.v.y; this.life-=0.05; }
    draw() { ctx.globalAlpha=Math.max(0,this.life); ctx.fillStyle=this.c; ctx.beginPath(); ctx.arc(this.x,this.y,3,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1; }
}

// --- LOGIC ---

function initGame() {
    game.players[game.myId] = { x:W/2, y:H/2, hp:100, active:true, id:game.myId, color:COLORS[game.myId] };
    document.getElementById('ui-layer').classList.remove('hidden');
    document.getElementById('controls-layer').classList.remove('hidden');
    document.getElementById('menu-screen').classList.add('hidden');
    document.getElementById('lobby-screen').classList.add('hidden');
    document.getElementById('client-wait-screen').classList.add('hidden');
    
    // Update Badges
    for(let i=0; i<4; i++) {
        const el = document.getElementById(`badge-p${i+1}`);
        if(game.players[i]) el.classList.add('active');
        else el.classList.remove('active');
    }
    
    game.active = true;
    requestAnimationFrame(loop);
}

function spawnEnemy() {
    const edge = Math.floor(Math.random()*4);
    let x,y;
    if(edge==0){x=Math.random()*W;y=-20;}
    if(edge==1){x=W+20;y=Math.random()*H;}
    if(edge==2){x=Math.random()*W;y=H+20;}
    if(edge==3){x=-20;y=Math.random()*H;}
    
    const hpMod = 1 + (game.wave * 0.2);
    game.enemies.push({ x:x, y:y, hp:30*hpMod, maxHp:30*hpMod, speed:1+(game.wave*0.05), id:Math.random() });
}

function updateState() {
    if(!game.active) return;

    // 1. Move Local Player
    const me = game.players[game.myId];
    if(me && me.hp > 0) {
        me.x += sticks.l.x * 6;
        me.y += sticks.l.y * 6;
        me.x = Math.max(20, Math.min(W-20, me.x));
        me.y = Math.max(20, Math.min(H-20, me.y));
        me.angle = Math.atan2(input.aimY, input.aimX);
        
        // Shooting
        if(input.firing) {
            const w = weapons[input.weapon];
            const now = Date.now();
            if(!me.lastShot || now - me.lastShot > (1000/60)*w.rate) {
                me.lastShot = now;
                playSound('shoot');
                const startAng = me.angle - (w.spread*(w.count-1))/2;
                
                // If HOST: Spawn bullet immediately
                // If CLIENT: Send shoot request, Host spawns it (simplified: client spawns local for prediction, host confirms)
                // For simplicity: Send input, Host spawns bullets for everyone.
                // BUT to make it snappy, Client spawns local visual bullet, Host does logic.
                
                if(game.mode === 'host' || game.mode === 'solo') {
                    for(let i=0; i<w.count; i++) {
                        const a = startAng + w.spread*i;
                        game.bullets.push({ x:me.x, y:me.y, vx:Math.cos(a)*w.spd, vy:Math.sin(a)*w.spd, c:me.color, dmg:w.dmg, owner:game.myId });
                    }
                }
            }
        }
    }

    // 2. Host Logic (Collisions, Spawning, Networking)
    if(game.mode !== 'client') {
        // Spawn Enemies (Rate based on player count)
        const pCount = Object.keys(game.players).length;
        if(Math.random() < 0.02 + (game.wave*0.005) + (pCount*0.005)) spawnEnemy();

        // Move Enemies
        game.enemies.forEach(e => {
            // Target nearest player
            let target = null, minDist = 9999;
            Object.values(game.players).forEach(p => {
                if(p.hp > 0) {
                    const d = Math.hypot(p.x - e.x, p.y - e.y);
                    if(d < minDist) { minDist = d; target = p; }
                }
            });
            if(target) {
                const ang = Math.atan2(target.y - e.y, target.x - e.x);
                e.x += Math.cos(ang) * e.speed;
                e.y += Math.sin(ang) * e.speed;
            }
        });

        // Collisions
        // Bullets -> Enemies
        game.bullets.forEach((b, bi) => {
            b.x += b.vx; b.y += b.vy;
            if(b.x<0||b.x>W||b.y<0||b.y>H) b.dead = true;
            
            game.enemies.forEach((e, ei) => {
                if(!b.dead && !e.dead && Math.hypot(b.x-e.x, b.y-e.y) < 20) {
                    e.hp -= b.dmg;
                    b.dead = true;
                    if(e.hp <= 0) {
                        e.dead = true;
                        game.score += 100;
                        game.shake = 5;
                        playSound('exp');
                        // Send particle event? Simply send score update
                    }
                }
            });
        });

        // Enemies -> Players
        game.enemies.forEach(e => {
            Object.values(game.players).forEach(p => {
                if(!e.dead && p.hp > 0 && Math.hypot(e.x-p.x, e.y-p.y) < 25) {
                    e.dead = true;
                    p.hp -= 20;
                    game.shake = 10;
                    playSound('exp');
                    if(p.hp < 0) p.hp = 0;
                }
            });
        });

        // Cleanup
        game.bullets = game.bullets.filter(b => !b.dead);
        game.enemies = game.enemies.filter(e => !e.dead);
        
        if(game.score > game.wave * 1000) game.wave++;
        
        // Broadcast State
        if(game.mode === 'host') {
            const packet = {
                t: 'state',
                pl: game.players,
                en: game.enemies,
                bu: game.bullets,
                sc: game.score,
                wv: game.wave
            };
            connList.forEach(c => c.send(packet));
        }
    } 
    else {
        // Client Logic: Send Input to Host
        if(conn && conn.open) {
            conn.send({
                t: 'input',
                x: me.x, y: me.y,
                fire: input.firing,
                aimX: input.aimX, aimY: input.aimY,
                wpn: input.weapon
            });
        }
    }
    
    // UI Update
    document.getElementById('score-display').innerText = game.score.toString().padStart(5,'0');
    document.getElementById('wave-display').innerText = "WAVE " + game.wave;
    if(game.players[game.myId]) {
        document.getElementById('hp-fill').style.width = game.players[game.myId].hp + '%';
    }
}

function draw() {
    ctx.fillStyle = '#0a0a12';
    ctx.fillRect(0,0,W,H);
    
    // Shake
    if(game.shake > 0) {
        ctx.save();
        ctx.translate((Math.random()-0.5)*game.shake, (Math.random()-0.5)*game.shake);
        game.shake *= 0.9;
        if(game.shake < 1) game.shake = 0;
    }

    // Grid
    ctx.strokeStyle = '#1a1a2e'; ctx.lineWidth = 1;
    ctx.beginPath();
    for(let i=0; i<W; i+=50) { ctx.moveTo(i,0); ctx.lineTo(i,H); }
    for(let i=0; i<H; i+=50) { ctx.moveTo(0,i); ctx.lineTo(W,i); }
    ctx.stroke();

    ctx.globalCompositeOperation = 'lighter'; // NEON GLOW

    // Bullets
    game.bullets.forEach(b => {
        ctx.fillStyle = b.c;
        ctx.shadowBlur = 10; ctx.shadowColor = b.c;
        ctx.beginPath(); ctx.arc(b.x, b.y, 4, 0, Math.PI*2); ctx.fill();
    });

    // Enemies
    game.enemies.forEach(e => {
        ctx.save(); ctx.translate(e.x, e.y);
        ctx.strokeStyle = '#ff0044'; ctx.shadowColor = '#ff0044'; ctx.shadowBlur = 15;
        ctx.lineWidth = 3;
        ctx.beginPath(); ctx.moveTo(0,-15); ctx.lineTo(15,15); ctx.lineTo(-15,15); ctx.closePath(); ctx.stroke();
        ctx.restore();
    });

    // Players
    Object.values(game.players).forEach(p => {
        if(p.active && p.hp > 0) {
            ctx.save(); ctx.translate(p.x, p.y);
            // Angle calc if not local
            if(p.id !== game.myId) {
                // simple interpolation visual could go here
            }
            
            ctx.strokeStyle = p.color; ctx.shadowColor = p.color; ctx.shadowBlur = 20;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(0,0,15,0,Math.PI*2);
            ctx.moveTo(0,-20); ctx.lineTo(0,0); // Direction indicator
            ctx.stroke();
            
            // Name/HP
            ctx.font = '10px Arial'; ctx.fillStyle = '#fff'; ctx.textAlign='center';
            ctx.fillText(`P${p.id+1}`, 0, -25);
            ctx.restore();
        }
    });

    if(game.shake > 0) ctx.restore();
    ctx.globalCompositeOperation = 'source-over';
    
    requestAnimationFrame(loop);
}

function loop() {
    updateState();
    draw();
}

// --- NETWORK LOBBY SYSTEM ---
let peer, conn;

function startSingle() {
    game.myId = 0;
    initGame();
}

function setupHost() {
    document.getElementById('menu-screen').classList.add('hidden');
    document.getElementById('lobby-screen').classList.remove('hidden');
    game.mode = 'host';
    game.myId = 0;
    
    // Add self to lobby list
    game.players[0] = { active:true, color:COLORS[0] };
    
    peer = new Peer();
    peer.on('open', (id) => {
        const url = window.location.href.split('?')[0] + '?join=' + id;
        document.getElementById('qr-img').src = `https://api.qrserver.com/v1/create-qr-code/?size=150x150&data=${encodeURIComponent(url)}`;
    });

    peer.on('connection', (c) => {
        if(connList.length >= 3) { c.close(); return; } // Max 4 players
        
        const newPid = connList.length + 1;
        connList.push(c);
        
        // Setup slot in Lobby UI
        updateLobbySlot(newPid, true);
        
        c.on('open', () => {
            // Send Welcome Packet with ID
            c.send({ t: 'welcome', id: newPid });
        });
        
        c.on('data', (data) => {
            if(data.t === 'input') {
                // Update remote player inputs
                if(!game.players[newPid]) game.players[newPid] = { active:true, hp:100, color:COLORS[newPid], x:W/2, y:H/2 };
                const p = game.players[newPid];
                p.x = data.x; p.y = data.y;
                
                // Handle remote firing
                if(data.fire) {
                     const w = weapons[data.wpn || 0];
                     const now = Date.now();
                     if(!p.lastShot || now - p.lastShot > (1000/60)*w.rate) {
                        p.lastShot = now;
                        playSound('shoot');
                        const angle = Math.atan2(data.aimY, data.aimX);
                        const startAng = angle - (w.spread*(w.count-1))/2;
                        for(let i=0; i<w.count; i++) {
                            const a = startAng + w.spread*i;
                            game.bullets.push({ x:p.x, y:p.y, vx:Math.cos(a)*w.spd, vy:Math.sin(a)*w.spd, c:p.color, dmg:w.dmg, owner:newPid });
                        }
                     }
                }
            }
        });
        
        c.on('close', () => {
            updateLobbySlot(newPid, false);
            delete game.players[newPid];
        });
    });
}

function updateLobbySlot(id, joined) {
    const slot = document.getElementById(`slot-p${id+1}`);
    const status = slot.querySelector('span:last-child');
    if(joined) {
        slot.classList.add('joined');
        status.innerText = "READY";
        status.style.color = COLORS[id];
    } else {
        slot.classList.remove('joined');
        status.innerText = "WAITING...";
        status.style.color = "#aaa";
    }
}

function hostStartGame() {
    // Notify all clients
    connList.forEach(c => c.send({ t: 'start' }));
    initGame();
}

// Client Side
const params = new URLSearchParams(window.location.search);
const joinId = params.get('join');

if(joinId) {
    document.getElementById('menu-screen').classList.add('hidden');
    document.getElementById('client-wait-screen').classList.remove('hidden');
    game.mode = 'client';
    
    peer = new Peer();
    peer.on('open', () => {
        conn = peer.connect(joinId);
        
        conn.on('open', () => {
            console.log("Connected to Host");
        });
        
        conn.on('data', (data) => {
            if(data.t === 'welcome') {
                game.myId = data.id;
                const badge = document.getElementById('my-color-badge');
                badge.style.backgroundColor = COLORS[game.myId];
                badge.style.boxShadow = `0 0 20px ${COLORS[game.myId]}`;
            }
            if(data.t === 'start') {
                initGame();
            }
            if(data.t === 'state') {
                // Sync World State
                game.enemies = data.en;
                game.bullets = data.bu;
                game.score = data.sc;
                game.wave = data.wv;
                
                // Update players (except self for smooth input, but take HP)
                Object.entries(data.pl).forEach(([pid, pData]) => {
                    const id = parseInt(pid);
                    if(id !== game.myId) {
                        game.players[id] = pData;
                    } else {
                        // Only sync HP for self, keep local position for smoothness
                        if(game.players[game.myId]) game.players[game.myId].hp = pData.hp;
                    }
                });
            }
        });
    });
}

</script>
</body>
</html>
