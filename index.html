<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Galaxy: Mobile Warfare</title>
    
    <!-- PeerJS for Multiplayer Networking -->
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@500;700&display=swap');

        * {
            box-sizing: border-box;
            touch-action: none; /* Prevents scroll/zoom on mobile */
            user-select: none;
            -webkit-user-select: none;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            overflow: hidden;
            font-family: 'Rajdhani', sans-serif;
            color: white;
        }

        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        /* --- UI LAYER --- */
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hud-top {
            padding: 15px;
            display: flex;
            justify-content: space-between;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
        }

        .score-box { font-size: 24px; color: #0ff; text-shadow: 0 0 10px #0ff; }
        .hp-box { font-size: 24px; color: #f00; text-shadow: 0 0 10px #f00; }

        /* --- CONTROLS --- */
        #controls-area {
            position: absolute;
            bottom: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; /* Let clicks pass through to canvas? No, specific zones */
            z-index: 5;
        }

        .control-zone {
            position: absolute;
            bottom: 20px;
            width: 150px; height: 150px;
            pointer-events: auto;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #joystick-zone { left: 20px; bottom: 20px; }
        #action-zone { right: 20px; bottom: 20px; }

        /* Joystick Visuals */
        .joystick-base {
            width: 120px; height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            position: relative;
        }

        .joystick-stick {
            width: 50px; height: 50px;
            background: rgba(0, 255, 255, 0.5);
            border-radius: 50%;
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 15px #0ff;
        }

        /* Buttons */
        .fire-btn {
            width: 90px; height: 90px;
            background: rgba(255, 50, 50, 0.3);
            border: 2px solid #f00;
            border-radius: 50%;
            display: flex;
            align-items: center; justify-content: center;
            font-size: 18px; font-weight: bold;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.4);
            transition: 0.1s;
        }
        .fire-btn:active { background: rgba(255, 50, 50, 0.8); transform: scale(0.95); }

        .switch-btn {
            position: absolute;
            bottom: 140px; right: 30px;
            width: 60px; height: 60px;
            background: rgba(255, 255, 0, 0.2);
            border: 1px solid #ff0;
            border-radius: 50%;
            pointer-events: auto;
            display: flex; align-items: center; justify-content: center;
            font-size: 24px;
        }

        /* --- MENUS --- */
        #menu-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(5, 5, 10, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            z-index: 20;
            text-align: center;
        }

        h1 {
            font-size: 4rem; margin: 0;
            background: linear-gradient(to right, #0ff, #f0f);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-transform: uppercase;
        }

        .btn-main {
            margin: 15px;
            padding: 15px 40px;
            font-size: 1.5rem;
            background: transparent;
            border: 2px solid #0ff;
            color: #0ff;
            font-family: inherit;
            border-radius: 30px;
            cursor: pointer;
            width: 80%;
            max-width: 400px;
        }

        .btn-main:active { background: #0ff; color: #000; }

        #qr-container {
            margin-top: 20px;
            background: white;
            padding: 10px;
            border-radius: 10px;
            display: none;
        }

        #lobby-status {
            margin-top: 10px;
            color: #aaa;
            font-size: 1.2rem;
            animation: pulse 1s infinite;
        }

        @keyframes pulse { 0%{opacity:0.5;} 50%{opacity:1;} 100%{opacity:0.5;} }

        /* Rotate Warning for Portrait Mode */
        #rotate-warning {
            display: none;
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 100;
            align-items: center; justify-content: center;
            flex-direction: column;
        }
        @media (orientation: portrait) {
            #rotate-warning { display: flex; }
        }
    </style>
</head>
<body>

    <!-- Rotation Warning -->
    <div id="rotate-warning">
        <div style="font-size: 50px;">ðŸ”„</div>
        <p>PLEASE ROTATE DEVICE</p>
    </div>

    <!-- Canvas -->
    <canvas id="gameCanvas"></canvas>

    <!-- Game UI -->
    <div id="ui-layer" style="display:none;">
        <div class="hud-top">
            <div class="score-box" id="scoreEl">SCORE: 0</div>
            <div class="hp-box" id="hpEl">HP: 100%</div>
        </div>

        <div id="controls-area">
            <!-- Left Stick -->
            <div id="joystick-zone" class="control-zone">
                <div class="joystick-base" id="joyBase">
                    <div class="joystick-stick" id="joyStick"></div>
                </div>
            </div>

            <!-- Weapon Switch -->
            <div class="switch-btn" id="btnSwitch">ðŸ”«</div>

            <!-- Fire Button -->
            <div id="action-zone" class="control-zone">
                <div class="fire-btn" id="btnFire">FIRE</div>
            </div>
        </div>
    </div>

    <!-- Main Menu -->
    <div id="menu-overlay">
        <h1>NEON GALAXY</h1>
        <p style="color: #888; margin-bottom: 30px;">MOBILE DEFENSE SYSTEM</p>
        
        <button class="btn-main" onclick="startSinglePlayer()">SINGLE PLAYER</button>
        <button class="btn-main" onclick="startHost()">MULTIPLAYER HOST</button>
        
        <div id="lobby-status"></div>
        <div id="qr-container">
            <img id="qr-img" src="" alt="Scan to Join" width="200" height="200" />
            <p style="color:#000; margin:5px 0 0 0; font-size:14px;">Scan to Join</p>
        </div>
        <p id="invite-link" style="font-size:12px; color:#555; margin-top:10px; user-select:text;"></p>
    </div>

<script>
/**
 * MOBILE GAME ENGINE & MULTIPLAYER LOGIC
 */

// --- CONFIGURATION ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let width, height;

// --- STATE ---
let gameActive = false;
let isMultiplayer = false;
let isHost = false;
let peer = null;
let conn = null;
let myId = null;

// Game Entities
let player = { x: 0, y: 0, angle: 0, hp: 100, weapon: 0, color: '#0ff' };
let remotePlayer = { active: false, x: 0, y: 0, angle: 0, hp: 100, color: '#f0f' };
let bullets = [];
let enemies = [];
let particles = [];
let score = 0;
let wave = 1;
let frames = 0;

// Inputs
const input = { x: 0, y: 0, fire: false, switch: false };

// --- AUDIO SYNTH (No external files) ---
const actx = new (window.AudioContext || window.webkitAudioContext)();
function playSound(type) {
    if(actx.state === 'suspended') actx.resume();
    const osc = actx.createOscillator();
    const gain = actx.createGain();
    const now = actx.currentTime;
    
    if (type === 'shoot') {
        osc.type = 'square';
        osc.frequency.setValueAtTime(300, now);
        osc.frequency.exponentialRampToValueAtTime(100, now + 0.1);
        gain.gain.setValueAtTime(0.1, now);
        gain.gain.linearRampToValueAtTime(0, now + 0.1);
        osc.start(now);
        osc.stop(now + 0.1);
    } else if (type === 'explode') {
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(100, now);
        osc.frequency.exponentialRampToValueAtTime(10, now + 0.3);
        gain.gain.setValueAtTime(0.2, now);
        gain.gain.linearRampToValueAtTime(0, now + 0.3);
        osc.start(now);
        osc.stop(now + 0.3);
    }
}

// --- RESIZE & FULLSCREEN ---
function resize() {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

// --- TOUCH CONTROLS (JOYSTICK) ---
const joyBase = document.getElementById('joyBase');
const joyStick = document.getElementById('joyStick');
const joyZone = document.getElementById('joystick-zone');
let joyTouchId = null;
let joyCenter = { x: 0, y: 0 };
const maxDist = 40;

joyZone.addEventListener('touchstart', e => {
    e.preventDefault();
    const touch = e.changedTouches[0];
    joyTouchId = touch.identifier;
    const rect = joyBase.getBoundingClientRect();
    joyCenter = { x: rect.left + rect.width/2, y: rect.top + rect.height/2 };
    updateJoystick(touch.clientX, touch.clientY);
}, {passive: false});

joyZone.addEventListener('touchmove', e => {
    e.preventDefault();
    for(let i=0; i<e.changedTouches.length; i++) {
        if(e.changedTouches[i].identifier === joyTouchId) {
            updateJoystick(e.changedTouches[i].clientX, e.changedTouches[i].clientY);
        }
    }
}, {passive: false});

joyZone.addEventListener('touchend', e => {
    e.preventDefault();
    resetJoystick();
}, {passive: false});

function updateJoystick(x, y) {
    let dx = x - joyCenter.x;
    let dy = y - joyCenter.y;
    const dist = Math.min(Math.hypot(dx, dy), maxDist);
    const angle = Math.atan2(dy, dx);
    
    const moveX = Math.cos(angle) * dist;
    const moveY = Math.sin(angle) * dist;
    
    joyStick.style.transform = `translate(calc(-50% + ${moveX}px), calc(-50% + ${moveY}px))`;
    
    // Normalize input -1 to 1
    input.x = moveX / maxDist;
    input.y = moveY / maxDist;
}

function resetJoystick() {
    joyTouchId = null;
    joyStick.style.transform = `translate(-50%, -50%)`;
    input.x = 0;
    input.y = 0;
}

// --- BUTTON CONTROLS ---
const btnFire = document.getElementById('btnFire');
const btnSwitch = document.getElementById('btnSwitch');

btnFire.addEventListener('touchstart', (e) => { e.preventDefault(); input.fire = true; btnFire.style.background='rgba(255,255,255,0.5)'; });
btnFire.addEventListener('touchend', (e) => { e.preventDefault(); input.fire = false; btnFire.style.background=''; });

btnSwitch.addEventListener('touchstart', (e) => {
    e.preventDefault();
    player.weapon = (player.weapon + 1) % 3;
    const icons = ['ðŸ”«', 'ðŸš€', 'âš¡'];
    btnSwitch.innerText = icons[player.weapon];
});


// --- GAME LOGIC ---

class Particle {
    constructor(x, y, color) {
        this.x = x; this.y = y; this.color = color;
        this.vx = (Math.random()-0.5)*5;
        this.vy = (Math.random()-0.5)*5;
        this.life = 1.0;
    }
    update() { this.x += this.vx; this.y += this.vy; this.life -= 0.05; }
    draw() {
        ctx.globalAlpha = Math.max(0, this.life);
        ctx.fillStyle = this.color;
        ctx.beginPath(); ctx.arc(this.x, this.y, 3, 0, Math.PI*2); ctx.fill();
        ctx.globalAlpha = 1;
    }
}

function spawnEnemy() {
    const side = Math.floor(Math.random()*4);
    let x, y;
    if(side===0) { x=Math.random()*width; y=-30; } // Top
    if(side===1) { x=width+30; y=Math.random()*height; } // Right
    if(side===2) { x=Math.random()*width; y=height+30; } // Bottom
    if(side===3) { x=-30; y=Math.random()*height; } // Left
    
    enemies.push({
        x: x, y: y,
        hp: 20 + (wave*5),
        speed: Math.random() * 1.5 + 1 + (wave*0.1),
        type: Math.random() > 0.8 ? 1 : 0 // 0: Follower, 1: Shooter
    });
}

function updateGame() {
    if(!gameActive) return;

    // Player 1 Movement
    player.x += input.x * 5;
    player.y += input.y * 5;
    
    // Bounds
    player.x = Math.max(20, Math.min(width-20, player.x));
    player.y = Math.max(20, Math.min(height-20, player.y));
    
    // Angle (face movement or maintain last angle)
    if(Math.abs(input.x) > 0.1 || Math.abs(input.y) > 0.1) {
        player.angle = Math.atan2(input.y, input.x);
    }

    // Shooting
    if(input.fire && frames % 10 === 0) {
        playSound('shoot');
        let speed = 12;
        let spread = 0;
        if(player.weapon === 1) spread = 0.2; // Spread
        
        bullets.push({x:player.x, y:player.y, vx:Math.cos(player.angle)*speed, vy:Math.sin(player.angle)*speed, owner:1});
        if(player.weapon === 1) {
            bullets.push({x:player.x, y:player.y, vx:Math.cos(player.angle-spread)*speed, vy:Math.sin(player.angle-spread)*speed, owner:1});
            bullets.push({x:player.x, y:player.y, vx:Math.cos(player.angle+spread)*speed, vy:Math.sin(player.angle+spread)*speed, owner:1});
        }
    }

    // Multiplayer Sync: Host receives Input, updates Remote Player
    // Multiplayer Sync: Client Just sends Input, receives State
    
    // Note: For this simplified standalone file, we will run logic on both sides loosely
    // But ideally, Host sends Enemy positions.
    // To keep it simple: Host spawns enemies and sends their positions. Client only renders them.
    
    if(isHost) {
        // Spawn Enemies
        if(frames % (100 - Math.min(50, wave*5)) === 0) spawnEnemy();
        
        // Move Enemies
        enemies.forEach(e => {
            // Target closest player
            let target = player;
            if(remotePlayer.active) {
                const d1 = Math.hypot(player.x - e.x, player.y - e.y);
                const d2 = Math.hypot(remotePlayer.x - e.x, remotePlayer.y - e.y);
                if(d2 < d1) target = remotePlayer;
            }
            
            const ang = Math.atan2(target.y - e.y, target.x - e.x);
            e.x += Math.cos(ang) * e.speed;
            e.y += Math.sin(ang) * e.speed;
        });

        // Send Game State to Client
        if(conn && conn.open) {
            conn.send({
                type: 'state',
                p1: {x: player.x, y: player.y, angle: player.angle},
                enemies: enemies,
                score: score,
                wave: wave
            });
        }
    }
    
    // Client Side: Interpolate Remote Player (The Host)
    // Actually, if we are Client, 'player' is US. 'remotePlayer' is HOST.
    
    // Update Bullets
    for(let i=bullets.length-1; i>=0; i--) {
        let b = bullets[i];
        b.x += b.vx;
        b.y += b.vy;
        
        // Cleanup
        if(b.x<0 || b.x>width || b.y<0 || b.y>height) { bullets.splice(i,1); continue; }
        
        // Collisions
        for(let j=enemies.length-1; j>=0; j--) {
            let e = enemies[j];
            let dist = Math.hypot(b.x - e.x, b.y - e.y);
            if(dist < 20) {
                bullets.splice(i,1);
                e.hp -= 10;
                if(e.hp <= 0) {
                    enemies.splice(j,1);
                    score += 100;
                    playSound('explode');
                    for(let k=0; k<5; k++) particles.push(new Particle(e.x, e.y, '#f00'));
                }
                break;
            }
        }
    }
    
    // Update Particles
    for(let i=particles.length-1; i>=0; i--) {
        particles[i].update();
        if(particles[i].life <= 0) particles.splice(i,1);
    }
    
    // Update UI
    document.getElementById('scoreEl').innerText = `SCORE: ${score}`;
    
    frames++;
}

function drawGame() {
    ctx.fillStyle = '#050510'; // Dark Blue Background
    ctx.fillRect(0, 0, width, height);
    
    // Grid
    ctx.strokeStyle = '#111122';
    ctx.lineWidth = 2;
    ctx.beginPath();
    for(let x=0; x<width; x+=50) { ctx.moveTo(x,0); ctx.lineTo(x,height); }
    for(let y=0; y<height; y+=50) { ctx.moveTo(0,y); ctx.lineTo(width,y); }
    ctx.stroke();

    // Draw Player (Me)
    drawShip(player.x, player.y, player.angle, player.color);
    
    // Draw Remote Player
    if(remotePlayer.active) {
        drawShip(remotePlayer.x, remotePlayer.y, remotePlayer.angle, remotePlayer.color);
    }
    
    // Draw Enemies
    enemies.forEach(e => {
        ctx.save();
        ctx.translate(e.x, e.y);
        ctx.rotate(frames * 0.1);
        ctx.shadowBlur = 10; ctx.shadowColor = '#f00';
        ctx.strokeStyle = '#f00';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(15,0); ctx.lineTo(-10,10); ctx.lineTo(-10,-10); ctx.closePath();
        ctx.stroke();
        ctx.restore();
    });
    
    // Draw Bullets
    ctx.fillStyle = '#fff';
    ctx.shadowBlur = 5; ctx.shadowColor = '#fff';
    bullets.forEach(b => {
        ctx.beginPath(); ctx.arc(b.x, b.y, 4, 0, Math.PI*2); ctx.fill();
    });
    ctx.shadowBlur = 0;
    
    // Particles
    particles.forEach(p => p.draw());
    
    requestAnimationFrame(loop);
}

function drawShip(x, y, angle, color) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(angle);
    ctx.shadowBlur = 15; ctx.shadowColor = color;
    ctx.fillStyle = '#000';
    ctx.strokeStyle = color;
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(20, 0);
    ctx.lineTo(-15, 15);
    ctx.lineTo(-10, 0);
    ctx.lineTo(-15, -15);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    ctx.restore();
}

function loop() {
    updateGame();
    drawGame();
}

// --- MULTIPLAYER SETUP ---

function startSinglePlayer() {
    document.getElementById('menu-overlay').style.display = 'none';
    document.getElementById('ui-layer').style.display = 'block';
    gameActive = true;
    isHost = true; // Acts as host for local logic
    player.x = width/2; player.y = height/2;
    loop();
}

function startHost() {
    isHost = true;
    isMultiplayer = true;
    document.getElementById('lobby-status').innerText = "Generating Link...";
    
    // Init Peer
    peer = new Peer();
    
    peer.on('open', (id) => {
        myId = id;
        const joinLink = window.location.href.split('?')[0] + '?join=' + id;
        
        // Generate QR Code via API
        const qrUrl = `https://api.qrserver.com/v1/create-qr-code/?size=200x200&data=${encodeURIComponent(joinLink)}`;
        document.getElementById('qr-img').src = qrUrl;
        document.getElementById('qr-container').style.display = 'block';
        document.getElementById('lobby-status').innerText = "Waiting for Player 2...";
        document.getElementById('invite-link').innerText = joinLink;
    });
    
    peer.on('connection', (c) => {
        conn = c;
        setupConnection();
        document.getElementById('lobby-status').innerText = "Player 2 Connected! Starting...";
        setTimeout(() => {
            document.getElementById('menu-overlay').style.display = 'none';
            document.getElementById('ui-layer').style.display = 'block';
            gameActive = true;
            remotePlayer.active = true;
            loop();
        }, 1000);
    });
}

function joinGame(hostId) {
    isHost = false;
    isMultiplayer = true;
    document.getElementById('menu-overlay').innerHTML = "<h1>JOINING...</h1>";
    
    peer = new Peer();
    peer.on('open', (id) => {
        conn = peer.connect(hostId);
        setupConnection();
        
        conn.on('open', () => {
            document.getElementById('menu-overlay').style.display = 'none';
            document.getElementById('ui-layer').style.display = 'block';
            gameActive = true;
            remotePlayer.active = true;
            loop();
        });
    });
}

function setupConnection() {
    conn.on('data', (data) => {
        if(isHost) {
            // Host receives P2 Input
            if(data.type === 'input') {
                remotePlayer.x = data.x;
                remotePlayer.y = data.y;
                remotePlayer.angle = data.angle;
                if(data.fire) {
                    // Spawn bullet for remote player
                     bullets.push({x:remotePlayer.x, y:remotePlayer.y, vx:Math.cos(remotePlayer.angle)*12, vy:Math.sin(remotePlayer.angle)*12, owner:2});
                     playSound('shoot');
                }
            }
        } else {
            // Client receives Game State
            if(data.type === 'state') {
                remotePlayer.x = data.p1.x; // Remote is Host
                remotePlayer.y = data.p1.y;
                remotePlayer.angle = data.p1.angle;
                enemies = data.enemies;
                score = data.score;
            }
        }
    });
    
    // Client sends input loop
    if(!isHost) {
        setInterval(() => {
            if(gameActive && conn.open) {
                // Client Logic: Move myself locally, send coords to host
                player.x += input.x * 5;
                player.y += input.y * 5;
                if(Math.abs(input.x) > 0.1 || Math.abs(input.y) > 0.1) player.angle = Math.atan2(input.y, input.x);

                conn.send({
                    type: 'input',
                    x: player.x,
                    y: player.y,
                    angle: player.angle,
                    fire: input.fire
                });
                
                // Reset fire flag to prevent machine gun stream if packet lag
                // input.fire = false; // Optional depending on feel
            }
        }, 1000/30);
    }
}

// --- INIT ---
const urlParams = new URLSearchParams(window.location.search);
const joinID = urlParams.get('join');

if(joinID) {
    joinGame(joinID);
}

</script>
</body>
</html>
